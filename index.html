<html>
<head>
<script>
	const original_join = Array.prototype.join;
	const sig_toString = "function toString() { [native code] }";
	const sig_toDateString = "function toDateString() { [native code] }";
	const sig_join = "function join() { [native code] }";
	console.warn('loaded detector');

	// detections return true if something was detected
	var detections = [
		function check_modification() {
			return Array.prototype.join !== original_join;
		},
		function check_toString_1() {
			return Array.prototype.join.toString() !== sig_join;
		},
		function check_toString_2() {
			return Function.prototype.toString.apply(Array.prototype.join, []) !== sig_join;
		},
		function check_toString_3() {
			return Function.prototype.toString.apply(Array.prototype.join.toString) !== sig_toString;
		},
		function check_toString_4() {
			return Object.getOwnPropertyDescriptor(Array.prototype.join, 'toString') !== undefined; // toString shouldn't be manually defined
		},
		function check_toString_5() {
			return Array.prototype.join.toString.toString() !== sig_toString;
		},
		function check_toString_6() {
			return Array.prototype.join.toString.name.includes('bind'); // if toString was manually defined by .bind
		},
		function check_toString_7() {
			return Date.prototype.toString.toString() !== sig_toString;
		},
		function check_toString_8() {
			return Function.prototype.toString.apply(Date.prototype.toString) !== sig_toString;
		},
		function check_arguments_1() {
			// make sure this is thrown
			try {
				Array.prototype.join.arguments;
			} catch(e) {
				return false;
			}
			return true;
		},
		function check_arguments_2() {
			return Object.getOwnPropertyDescriptor(Array.prototype.join, 'arguments') !== undefined;
		},
		function check_prototype() {
			// from Lemons#0001 https://github.com/Lemons1337/
			return "prototype" in Array.prototype.join;
		},
		function sanity_check() {
			try {
				return ['1', 2, {'toString': () => '3'}].join(',') !== '1,2,3';
			} catch(e) {
				return true;
			}
			return false;
		},
		function check_stack_1() {
			// detect proxy since they will have to call the actual function -> increased stack trace lines
			Error.stackTraceLimit = 10;
			try {
				Array.prototype.join.apply();
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.split('\n').length !== 4; // a tailored stack trace check
			}
			return true;
		},
		function check_stack_2() {
			// join and many other functions will implicitly call toString on arguments so rig toString to inspect the stack for increased size
			// this is one of the harder detection vectors for an adversary to truly fix since they cannot intercept the exception in this case
			// consider concealing the rigged 'toString'
			// worth noting that there exists a way to modify the full stack trace to anything without catching/throwing: https://github.com/hrt/StackTraceSpoofJS
			var arr = [
				{
					'toString': () => {
						Error.stackTraceLimit = 10;
						try {
							null.test
						} catch(e) {
							const stack = e.stack;
							console.log('%s\n----\n%s', arguments.callee.name, stack);
							if (stack.split('\n').length !== 5) {
								return 'DETECTED';
							}
						}
						return '';
					}
				}
			];
			return arr.join() === 'DETECTED';
		},
		function check_stack_3() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toString.apply(Array.prototype.join, []);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.includes('Proxy.toString') || stack.includes('apply') || !stack.includes(sig_join);
			}
			return true;
		},
		function check_stack_4_toString() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toString.apply(Array.prototype.join.toString, []);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_toString)
			}
			return true;
		},
		function check_stack_5_toString() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toDateString.apply(Array.prototype.join.toString, []);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_toString);
			}
			return true;
		},
		function check_stack_6() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toDateString.apply(Array.prototype.join, []);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.includes('Proxy.toString') || stack.includes('apply') || !stack.includes(sig_join);
			}
			return true;
		},
		function check_stack_7_toString() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toString.apply(Function.prototype.toString);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.includes('Proxy.toString') || stack.includes('apply') || !stack.includes(sig_toString);
			}
			return true;
		},
		function check_stack_8_toString() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toDateString.apply(Function.prototype.toString);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.includes('Proxy.toString') || stack.includes('apply') || !stack.includes(sig_toString);
			}
			return true;
		},
		function check_stack_9_toString() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toDateString.apply(Date.prototype.toString);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.includes('Proxy.toString') || stack.includes('apply') || !stack.includes(sig_toString);
			}
			return true;
		},
		function check_stack_10_toString() {
			Error.stackTraceLimit = 10;
			try {
				Date.prototype.toString.apply(Date.prototype.toDateString);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.includes('Proxy.toString') || stack.includes('apply') || !stack.includes(sig_toDateString);
			}
			return true;
		},
		function check_stack_11_object_create() {
			// from Lemons#0001 https://github.com/Lemons1337/
			try {
				Object.create(Array.prototype.join).toString();
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return stack.includes('at Object.toString (<anonymous>)');
			}
			return true;
		},
		function check_stack_12_in() {
			// from Lemons#0001 https://github.com/Lemons1337/
			try {
				Array.prototype.join in 0;
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_join);
			}
			return true;
		},
		function check_stack_13_toString_in() {
			// from Lemons#0001 https://github.com/Lemons1337/
			try {
				Array.prototype.join.toString in 0;
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_toString);
			}
			return true;
		},
		function check_stack_14_toLocaleDateString() {
			// from Lemons#0001 https://github.com/Lemons1337/
			try {
				Date.prototype.toLocaleDateString.call(Array.prototype.join);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_join);	
			}
			return true;
		},
		function check_stack_15_toLocaleDateString() {
			try {
				Date.prototype.toLocaleDateString.call(Array.prototype.join);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_join);	
			}
			return true;
		},
		function check_stack_16_ArrayBuffer_slice() {
			try {
				ArrayBuffer.prototype.slice(Array.prototype.join);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes("incompatible receiver #<ArrayBuffer>");	
			}
			return true;
		},
		function check_stack_17_BigUint64Array_slice() {
			try {
				BigUint64Array.prototype.slice.apply(Array.prototype.join);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_join);	
			}
			return true;
		},
		function check_stack_18_BigUint64Array_sort() {
			try {
				BigUint64Array.prototype.sort.apply(Array.prototype.join);
			} catch(e) {
				const stack = e.stack;
				console.log('%s\n----\n%s', arguments.callee.name, stack);
				return !stack.includes(sig_join);	
			}
			return true;
		}
	];

	// wait for cheats to load
	setTimeout(() => { 
		var ul = document.getElementById('detections');
		var hits = 0;
		for (var i = 0; i < detections.length; i++) {
			var detected = true;
			try {
				var detected = detections[i]();
			} catch(e) {}
			if (detected) {
				var msg = 'DETECTED: ' + detections[i].name;
				console.warn(msg);
				var li = document.createElement("LI");
				li.append(document.createTextNode(msg));
				li.classList.add('fail');
				ul.appendChild(li);
				hits += 1;
			}
		}
		if (!hits) {
			var li = document.createElement("LI");
			li.append(document.createTextNode('No hook detected (Array.prototype.join)'));
			li.classList.add('pass');
			ul.appendChild(li);
		}
	}, 200);
</script>
<style>
	body {
		background-color: black;
	}
	.pass {
		color: green
	}
	.fail {
		color: red
	}
</style>
</head>
<body>
	<ul id='detections'></ul>
</body>
</html>
