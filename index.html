// ==UserScript==
// @name         Tamper conceal solution
// @match        file:///home/gecko/TamperDetectJS/index.html
// @run-at       document-start
// @grant        none
// ==/UserScript==

(() => {
    var hook_to_og = new WeakMap();
    // more of these to do, but that's sleeper - can do it later
    var apply = Function.prototype.apply;
    var toString = Function.prototype.toString;
    function clean(trace) {
        var matches = trace.match(/\(\.\.\.args\) \=\>[\s|\S]*\.\.\.<omitted>\.\.\. \}/);
        if (matches) {
            var rep = matches[0];
            matches = rep.match(/\/\*(\w+\.\w+\.\w+)\*\//);
            if (matches && matches.length == 2) {
                var keys = matches[1].split('.');
                var og = hook_to_og.get(window[keys[0]][keys[1]][keys[2]]);
                const tmp = Function.prototype.toString;
                Function.prototype.toString = toString;
                trace = trace.replace(rep, og.toString());
                Function.prototype.toString = tmp;
            }
        }
        return trace;
    }
    // Error is yet to be hidden (incl delete proof and preserve behavior..)
    Error.prepareStackTrace = function(error, structuredStackTrace) {
        var stack = clean(error.stack);
        return stack.replace(/.*chrome-extension.*\n/g, '');
    };
    Reflect.defineProperty(TypeError.prototype, 'name', {
        get: function() {
            this.message = clean(this.message);
            return 'TypeError';
        }
    });
    function hook(parent_name, key, is_prototype, replace_all) {
        try {
            var parent = is_prototype ? window[parent_name].prototype : window[parent_name];
            var og = parent[key]
            if (!og) {
                return;
            }
            if (hook_to_og.get(parent[key])) {
                return; // we're already hooked
            }
            parent[key] = eval(`
                (...args) => {/*` + [parent_name, 'prototype', key].join('.') + `*/
                    var prepareStackTrace = Error.prepareStackTrace;
                    Error.prepareStackTrace = function(error, structuredStackTrace) {
                        return structuredStackTrace[0].getThis();
                    };
                    try {
                        null.test;
                    } catch(e) {
                        that = e.stack;
                    }
                    if (that === window) {
                        // this is a hack and fails edge case .join on window
                        // I'm yet to think of a clean way to figure out if 'this' is null..
                        that = undefined;
                    }
                    delete Error.prepareStackTrace;
                    Error.prepareStackTrace = prepareStackTrace;

                    if (replace_all) {
                        var new_args = [];
                        that = hook_to_og.get(that) || that;
                        for (var i = 0; args && i < args.length; i++) {
                            new_args[i] = hook_to_og.get(args[i]) || args[i];
                        }
                        args = new_args;
                    }

                    try {
                        // temporary solution to an annoying problem
                        const tmp = Function.prototype.apply;
                        Function.prototype.apply = apply;
                        var ret = og.apply(that, args);
                        Function.prototype.apply = tmp;
                        return ret;
                    } catch (e) {
                        if (!replace_all) {
                            var new_args = [];
                            that = hook_to_og.get(that) || that;
                            for (var i = 0; args && i < args.length; i++) {
                                new_args[i] = hook_to_og.get(args[i]) || args[i];
                            }
                            args = new_args;
                            // temporary solution to an annoying problem
                            const tmp = Function.prototype.apply;
                            Function.prototype.apply = apply;
                            var ret = og.apply(that, args);
                            Function.prototype.apply = tmp;
                            return ret;

                        } else {
                            throw e;
                        }
                    }
                }`);
            var descriptors = Object.getOwnPropertyDescriptors(og);
            for (var attrib in descriptors) {
                if (descriptors.hasOwnProperty(attrib)) {
                    Reflect.defineProperty(parent[key], attrib, descriptors[attrib]);
                }
            }
            hook_to_og.set(parent[key], og);
        } catch(e) {}
    }
    hook('Array', 'join', true, false);
    hook('Function', 'toString', true, true);
    hook('window', 'postMessage', false, true);
    hook('history', 'pushState', false, true);
})();
